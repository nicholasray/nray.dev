---
title: How to Create Performant Scroll Animations
coverFile: "cover.svg"
publishedAt: "2022-10-02"
description: Learn how to create scroll-triggered animations without jank.
---

There are some web pages out in the wild with designs and functionality that
leave me in awe. [Github's](https://www.github.com) logged-out homepage with its
beautiful design, 3d interactive globe, and scroll-triggered animations is one
example. In fact, their work inspired several of the design elements found on my
[homepage](https://www.nray.dev), including their scroll-triggered animations
that beautifully fade in and translate.

Performant web animations can be tricky to get right, though. Coupling these
animations with a high-frequency critical event like scrolling increases the
stakes. Done poorly, they can lead to a frustrating and janky user experience.

In this post, I will show you how to avoid the common pitfalls and incorporate
performant animations that can delight your users. Let's get started!

## Staying off the main thread

If you want animations to have the best chance of looking smooth to your users,
you have to make them run somewhere free from interference. Smooth animations
achieve consistent and rapid frame production. Interference can prevent the
browser from producing frames as fast as the screen's refresh rate, leading to
janky animations. For example, if the screen refreshes at a rate of 60 times a
second (typical for most monitors), the browser must produce each frame within
16.667 milliseconds for the animation to look smooth. Higher-end 120 hertz
monitors cut this budget in half and require frames made in 8.333 milliseconds.
The animation will look slow and sluggish if the browser doesn't meet this
deadline.

To make matters worse, there are many potential sources of interference. The
browser's parsing of HTML sent from the server when the page is loading can
cause interference. The execution of JavaScript can interfere. The browser's
[rendering steps](https://developer.chrome.com/blog/inside-browser-part3/) like
when it computes the styles of elements, determines an element's geometry and
position, or creates paint records are all sources of jank. And that's not
everything!

All the sources of interference mentioned previously run on the main thread of
the browser's renderer process. The main thread is a dangerous place. We want to
avoid running our animations here because the competition is too fierce. Only
one thing can execute on the main thread at a time, and the risk is too high
that it will be something other than our animation.

The best place to run animations is where none of these competing events happen.
Luckily, another thread, the compositor thread, has much less stuff happening.
As a result, it is much less prone to jank. There is a slight catch, though -
`opacity` and `transform` are the only compositor thread-friendly CSS
properties. Therefore, attempting to animate any other property will make your
animation run on the main thread. Still, you might be surprised how much you can
achieve with only these properties.

## Detecting when an element has entered the viewport

To trigger animations when a user scrolls, we need to detect when the element
we'd like to animate has entered the viewport. Once it has sufficiently entered
the viewport, we want the animation to begin. In the past, we might have
achieved this with a scroll event listener:

```js
const animatable = document.querySelector(".animatable");

const handler = () => {
  // Check the position of the element relative to the viewport.
  const position = element.getBoundingClientRect();

  // Check if the top of the element has crossed the bottom of the viewport.
  if (position.top >= 0 && position.top < window.innerHeight) {
    // Element's top has crossed the bottom of the viewport so start the
    // animation by removing the class that controls its starting position.
    animatable.classList.remove("animatable--initial");
    // Remove event listener once the animation has started since we don't need
    // it anymore.
    window.removeEventListener("scroll", handler);
  }
};

window.addEventListener("scroll", handler);
```

However, this approach can cause a couple of problems:

- We have to check the element's position relative to the viewport on each
  scroll event. This frequent querying occurs on the main thread which has
  potential to cause jank to other areas of the user experience (e.g.
  scrolling).

- Relatedly, calling `element.getBoundingClientRect()` can be an expensive call.
  It can make the browser perform
  [expensive style recalc and layout operations](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)
  which ties up the main thread even more.

It would be much better if the browser could fire our callback when it has
detected that our element of interest has entered the viewport instead of being
forced to query this information on every scroll event. Fortunately, there is a
way with the Intersection Observer API.

## Using Intersection Observer to trigger scroll-down animations

Use the Intersection Observer API to detect when an element enters or leaves the
viewport without the expensive querying that the use of a scroll event listener
might cause. Instead, Intersection Observer detects changes in a way that stay
off the main thread!

```js
const animatable = document.querySelector(".animatable");

const options = {
  // Fire callback as soon as little as one pixel is visible in the viewport.
  threshold: 0,
};
const callback = () => {
  // Change in the intersection of one or more observed elements.
};

const observer = new IntersectionObserver(callback, options);

observer.observe(animatable);
```

The callback passed to Intersection Observer will be called whenever
intersection changes are associated with the observed element. It's important to
note that the code in this callback _will_ take place on the main thread so we
shouldn't do anything costly while we're in there. Writing efficient code in
this callback is fairly easy to do, however, because the information that the
callback's `entries` param contains is usually all we need to determine whether
we should trigger the animation. Using Intersection Observer instead of a scroll
event listener in our the previous example would look like this:

```js showLineNumbers
const element = document.querySelector(".animatable");

const observer = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    // Only start animation when the top of the element intersects with the
    // bottom of the viewport. Note that `entry.boundingClientRect.top` will be
    // negative when the top of the element is above the viewport.
    if (entry.isIntersecting && entry.boundingClientRect.top > 0) {
      // Element's top has crossed the bottom of the viewport and is within the
      // viewport so start animation by removing it's the class that sets its
      // starting position.
      element.classList.remove("animatable--initial");
      // Stop observing intersection changes once the animation has started
      // since we only want to run the animation once.
      observer.disconnect();
    }
  });
});

// Start observing element.
observer.observe(element);
```

You may have noticed that on line 8 we check the `boundingClientRect` property
of the element and wonder how this is any different than the call to
`getBoundingClientRect()` that was cited as potentially problematic and
expensive in the previous example that used a scroll event listener. Although
the calls look similar, there are a couple of important differences:

- Unlike `getBoundingClientRect()`, calling `boundingClientRect` returns a
  cached value. This value will always be the element's position when the
  intersection change occurred, which may be different from the element's
  current position. This could happen, for example, if you call
  `boundingClientRect` in a `setTimeout`, scroll, and then wait for the
  `setTimeout` callback to fire. The position reported by `boundingClientRect`
  will be the same as before the scroll took place. Because this call is cached
  and is not doing a live computation of the element's position, it is
  relatively fast.
- The second reason it's more efficient is that it does not cause the browser to
  perform
  [expensive style recalc and layout operations](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)
  that calling `element.getBoundingClientRect()` might incur. Instead, the
  browser queries this information at a time that is most efficient within the
  rendering pipeline.

## Creating scroll animations in React with Intersection Observer

Now with all the theory out of the way, let's see how we could build
scroll-triggered animations using Intersection Observer in React and Typescript.
Let's take advantage of React Hooks to create something simple and reusable.

### Step 1: Create a new hook

First, following the conventions of React Hooks, let's create a new file with
the following boilerplate.

```ts showLineNumbers title="useIntersectionObserver.ts"
import { useEffect, useState } from "react";

type ReturnType = [
  (element: Element | null) => void,
  IntersectionObserverEntry | null
];

interface Options extends IntersectionObserverInit {
  /**
   * Disable detecting intersection changes. Use this if the user has enabled
   * the "prefer-reduced-motion" setting on their OS, for example.
   */
  isDisabled?: boolean;
}

/**
 * A React Hook used to observe intersection changes with elements.
 *
 * @param options
 */
function useIntersectionObserver({
  root = null,
  rootMargin = "0%",
  threshold = 0,
  isDisabled = false,
}: Options): ReturnType {}

export default useIntersectionObserver;
```

### Step 2: Add state and a ref to the element

We need to add two bits of state to our hook. First, we need to store a
reference to the element we want to observe. We take advantage of React's
support for
[callback refs](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) by
passing the `setRef` callback to the client of the hook. We also store the
intersection observer entry which will be `null` when the component first
renders.

```ts showLineNumbers title="useIntersectionObserver.js" {7-8}
function useIntersectionObserver({
  root = null,
  rootMargin = "0%",
  threshold = 0,
  isDisabled = false,
}: Options): ReturnType {
  const [ref, setRef] = useState<Element | null>(null);
  const [entry, setEntry] = useState<IntersectionObserverEntry | null>(null);

  return [setRef, entry];
}

export default useIntersectionObserver;
```

### Step 3: Create IntersectionObserver instance inside useEffect hook

To create our instance of `IntersectionObserver` and start observing our
element, we need to add a `useEffect` hook. In the callback passed to the
`IntersectionObserver` constructor we'll set the entry state. This callback will
be triggered upon intersection changes. We return a cleanup function from the
effect which will run when any of the dependencies passed as a second argument
to `useEffect` changes or if the component unmounts.

```ts showLineNumbers title="useIntersectionObserver.js" {10-39}
function useIntersectionObserver({
  root = null,
  rootMargin = "0%",
  threshold = 0,
  isDisabled = false,
}: Options): ReturnType {
  const [ref, setRef] = useState<Element | null>(null);
  const [entry, setEntry] = useState<IntersectionObserverEntry | null>(null);

  useEffect(
    () => {
      // Return early if `isDisabled` is `true`, or if we don't have a reference to
      // the element, or if the browser doesn't support IntersectionObserver.
      if (isDisabled || !ref || !window.IntersectionObserver) {
        return;
      }

      // Create a new IntersectionObserver instance where we'll set the entry
      // state when intersection changes are detected.
      const observer = new IntersectionObserver(
        ([entry]) => {
          setEntry(entry);
        },
        { root, rootMargin, threshold }
      );

      // Start observing the element.
      observer.observe(ref);

      // Cleanup function;
      return () => {
        observer.disconnect();
      };
    },
    // Avoid excessive re-renders by converting threshold to a string if it is
    // an array.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [root, rootMargin, JSON.stringify(threshold), ref, isDisabled]
  );

  return [setRef, entry];
}
```

Clients can then use this hook in the following example:

```tsx showLineNumbers title="App.tsx"
import { useEffect, useState } from "react";
import useIntersectionObserver from "./useIntersectionObserver";
import "./styles.css";

interface AnimatableProps {
  children: React.ReactNode;
}

/**
 * Animates an element when at least 35% of the element is within the viewport
 * including its top.
 */
function Animatable({ children }: AnimatableProps) {
  const [isDisabled, setIsDisabled] = useState(false);
  const [ref, entry] = useIntersectionObserver({
    // Trigger callback when at least 35% of the element is visible in the
    // viewport.
    threshold: 0.35,
    isDisabled: isDisabled,
  });

  // Only transform the element if we don't have an `IntersectionEntry` for the
  // element yet (e.g. on the initial render) or if the element isn't
  // intersecting with the viewport, and the top of the element is below the
  // bottom of the viewport.
  const shouldTransform: boolean =
    !entry || (!entry.isIntersecting && !!(entry.boundingClientRect.top > 0));

  // Only trigger the animation once.
  useEffect(() => {
    if (entry && !shouldTransform) {
      setIsDisabled(true);
    }
  }, [entry, shouldTransform]);

  return (
    <div
      ref={!isDisabled ? ref : undefined}
      className={`animatable ${
        shouldTransform ? "animatable--initial" : ""
      }`.trim()}
    >
      {children}
    </div>
  );
}

export default function App() {
  const animatables = [];
  for (let i = 0; i < 20; i++) {
    animatables.push(<Animatable key={i}>{i}</Animatable>);
  }

  return (
    <section>
      <div className="container">{animatables}</div>
    </section>
  );
```

### Step 4: Animate responsibly

When adding any feature to a website, it's essential to consider its
accessibility implications. For example, not everyone likes animations, and many
people have vestibular motion disorders where animations can actually cause
harm. Therefore, we should allow users to opt out of any animation we add to a
website.

One relatively easy way we can achieve this is to use the
`prefers-reduced-motion` media query to only enable the animation when the user
has enabled the "reduce motion" setting in their operating system. Using the
media query, if the user prefers reduced motion, the ending point of the
animation is rendered and the transition will be inert.

I also like to disable scroll-triggered animations on mobile devices since they
are much more prone to jank due to having less powerful hardware in general.
Unfortunately, there aren't media queries that explicitly target mobile devices,
but we can use the viewport's width as a sufficient proxy. Therefore, we will
only enable the animation if the viewport exceeds a minimum width.

```css showLineNumbers title="styles.css"
.animatable {
  display: flex;
  align-items: center;
  padding-left: 48px;
  padding-right: 48px;
  height: 500px;
  justify-content: center;
  background: #cbd5e1;
  color: #0f172a;
  font-size: 24px;
  border-radius: 16px;
}

/** 
 * Only enable animations for devices with relatively large viewport widths
 * which serves as a proxy for devices with more power and for users who haven't set the
 * "prefers reduced motion" setting on their OS.
 */
@media (prefers-reduced-motion: no-preference) and (min-width: 640px) {
  .animatable {
    transition-duration: 500ms;
    /** 
    * Limit transitions to compositor thread-friendly properties for the best
    * performance. 
    */
    transition-property: transform, opacity;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  }
}

@media (prefers-reduced-motion: no-preference) and (min-width: 640px) {
  .animatable--initial {
    transform: translateX(33%);
    opacity: 0.6;
  }
}
```

Your result should now be similar to the demo below. Keep in mind that you won't
see the animation if your viewport is less than 640px due to the media query
styles we set.

<CodeEditor
  src={[
    "demos/react-scroll-animations/src/App.tsx",
    "demos/react-scroll-animations/src/useIntersectionObserver.ts",
    "demos/react-scroll-animations/src/styles.css",
  ]}
/>
