---
title: How to Create Performant Scroll Animations
coverFile: "cover.svg"
description: Scroll animation description
---

There are a number of webpages out in the wild with designs and functionality
that leave me in awe. [Github's](https://www.github.com) homepage with its
beautiful design, 3d interactive globe and scroll-triggered animations is one
example of that. Several of the design elements found on my
[homepage](https://www.nray.dev) are inspired by their work including their
scroll-triggered animations that fade-in and translate several of their
elements.

Performant web animations can be tricky to get right though. Coupling these
animations with a high-frequency critical event like scrolling makes the stakes
even higher. If done inefficiently, it can cause lead to a frustrating and janky
user experience.

In this post, I will show you how to avoid the common pitfalls and incorporate
performant animations that can delight your users. Let's get started!

## Staying off the main thread

If you want your web animations to have the best chance of looking smooth to
your users, you have to make them run somewhere that is free from interference.
Smooth animations achieve consistent and rapid frame production. Interference
can make the browser not produce frames as fast as the screen's refresh rate
which leads to janky animations. For example, if the screen refreshes at a rate
of 60 times a second, the browser must produce a frame within 16.667
milliseconds in order for the animation to look smooth. Higher-end 120Hz
monitors can cut this budget in half and require frames produced in 8.333
milliseconds. If the browser doesn't meet this deadline, the animation will look
slow and sluggish.

To make matters worse, there are many potential sources of interference. The
browser's parsing of HTML sent from the server when the page is loading can
cause interference. The execution of JavaScript can interfere. The browser's
[rendering steps](https://developer.chrome.com/blog/inside-browser-part3/) like
when it computes the styles of elements, determines an element's geometry and
position, or creating paint records is another big source. And that's not
everything!

All of the sources of jank mentioned previously run on the main thread of the
browser's renderer process. The main thread is a dangerous place. We want to
avoid running our animations here as the competition is just too fierce.

The best place to run animations is where none of these competing events happen.
Luckily, there is another thread, the compositor thread, which has a lot less
stuff going on in it. As a result, it is much less prone to jank. There is a
slight catch though - the only compositor thread friendly css properties are
`opacity` and `transform`. Attempting to animate any other property will make
your animation run on the main thread. Still, you might be surprised just how
much you can achieve only using these two properties. Whats more, limiting your
animations to these properties will give you the best shot at achieving
performant animations.

## Detecting when an element has entered the viewport

To trigger animations when a user scrolls, we need to somehow detect when the
element we'd like to animate has entered the viewport. Once it has sufficiently
entered the viewport, we want the animation to begin. In the past, we might have
achieved this with a scroll event listener:

```js
const animatable = document.querySelector(".animatable");

const handler = () => {
  // Check the position of the element relative to the viewport.
  const position = element.getBoundingClientRect();

  // Check if the top of the element has crossed the bottom of the viewport.
  if (position.top >= 0 && position.top < window.innerHeight) {
    // Element's top has crossed the bottom of the viewport so start the
    // animation by removing the class that controls its starting position.
    animatable.classList.remove("animatable--initial");
    // Remove event listener once the animation has started since we don't need
    // it anymore.
    window.removeEventListener("scroll", handler);
  }
};

window.addEventListener("scroll", handler);
```

However, this approach can cause a couple problems:

- We have to check the element's position relative to the viewport on each
  scroll event. This frequent querying occurs on the main thread which has
  potential to cause jank to other areas of the user experience (e.g.
  scrolling).

- Relatedly, calling `element.getBoundingClientRect()` can be an expensive call.
  It can cause the browser to perform
  [expensive style recalc and layout operations](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)
  which ties up the main thread even more.

It would be much better if the browser could just fire our callback when it has
detected that our element of interest has entered the viewport instead of us
querying this information on every scroll event. Fortunately, there is a way
with the Intersection Observer API.

## Using Intersection Observer to trigger scroll down animations

The Intersection Observer API can be used to detect when an element enters or
leaves the viewport without using a scroll event listener that queries the
position of an element each scroll event. The best part is that this detection
stays off the main thread!

```js
const animatable = document.querySelector(".animatable");

const options = {
  // Fire callback as soon as little as one pixel is visible in the viewport.
  threshold: 0,
};
const callback = () => {
  // Change in the intersection of one or more observed elements.
};

const observer = new IntersectionObserver(callback, options);

observer.observe(animatable);
```

The callback passed to Intersection Observer will be called whenever there are
intersection changes associated with the element being observed. It's important
to note that the code in this callback _will_ take place on the main thread so
we shouldn't do anything very expensive while we're in there. This is fairly
easy to do, however, because the information that the callback's `entries` param
contains is usually all we need to determine whether we should trigger the
animation. Using Intersection Observer instead of a scroll event listener in our
previous example would look like this:

```js showLineNumbers
const element = document.querySelector(".animatable");

const observer = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    // Only start animation when the top of the element intersects with the
    // bottom of the viewport. Note that `entry.boundingClientRect.top` will be
    // negative when the top of the element is above the viewport.
    if (entry.isIntersecting && entry.boundingClientRect.top > 0) {
      // Element's top has crossed the bottom of the viewport so start animation.
      element.classList.remove("animatable--initial");
      // Stop observing intersection changes once the animation has started
      // since we only want to run the animation once.
      observer.disconnect();
    }
  });
});

// Start observing element.
observer.observe(element);
```

You may have noticed that on line 8 we check the `boundingClientRect` property
of the elment and wonder how this is any different than the call to
`getBoundingClientRect()` that was cited as potentially problematic and
expensive in the previous example that used a scroll event listener. Although
the calls look similar, there are a couple of important differences:

- Unlike `getBoundingClientRect()`, calling `boundingClientRect` returns a
  cached value. This value will always be the element's position when the
  intersection change occurred which may in fact be different than the element's
  current position. This could happen, for example, if you call
  `boundingClientRect` in a `setTimeout`, scroll, and then wait for the
  `setTimeout` callback to fire. The position reported by `boundingClientRect`
  will be the same as before the scroll took place. Because this call is cached
  and is not actually doing a live computation of the element's position, it is
  fast.
- The second reason it is more efficient is because it does not cause the
  browser to perform
  [expensive style recalc and layout operations](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)
  that calling `element.getBoundingClientRect()` might incur. Instead, the
  browser queries this information at a time that is most efficient within the
  rendering pipeline.

## Creating scroll animations in React with Intersection Observer

Now with all the theory out of the way, let's see how we could build
scroll-triggered animations using Intersection Observer in React and Typescript.
Let's take advantage of React Hooks to build something that is simple and
reusable.

### Step 1: Create a new hook

First, following conventions of React Hooks, let's create a new file with the
following boilerplate.

```js showLineNumbers title="useIntersectionObserver.ts"
/**
 * A react hook used to observe intersection changes with elements.
 *
 * @param options Options passed to the IntersectionObserver constructor.
 */
function useIntersectionObserver(options) {}

export default useIntersectionObserver;
```

### Step 2: Add state

We need to add two bits of state to our hook. First, we need to store a
reference to the element we want to observe. We take advantage of React's
support for
[callback refs](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) by
passing the `setRef` callback to the client of the hook. We also store the
intersection observer entry which will be null when the component first renders.

```js showLineNumbers title="useIntersectionObserver.js" {7-8}
/**
 * A react hook used to observe intersection changes with elements.
 *
 * @param options Options passed to the IntersectionObserver constructor.
 */
function useIntersectionObserver(options) {
  const [ref, setRef] = useState(null);
  const [entry, setEntry] = useState(null);

  return [setRef, entry];
}

export default useIntersectionObserver;
```

### Step 3: Add effect

In order to create our instance of Intersection Observer and start observing our
element, we need to add a `useEffect` hook. In the callback passed to the
`IntersectionObserver` constructor, we'll set the entry state.

```js showLineNumbers title="useIntersectionObserver.js" {15-40}
/**
 * A react hook used to observe intersection changes with elements.
 *
 * @param options Options passed to the IntersectionObserver constructor.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver#properties
 */
function useIntersectionObserver({
  root = null,
  rootMargin = "0%",
  threshold = 0,
}) {
  const [ref, setRef] = useState(null);
  const [entry, setEntry] = useState(null);

  useEffect(
    () => {
      // Return early if we don't have a reference to the element yet or the
      // browser doesn't support IntersectionObserver.
      if (!ref || !window.IntersectionObserver) {
        return;
      }

      // Create new Intersection Observer instance where we'll set they entry
      // state when intersection changes are detected.
      const observer = new IntersectionObserver(([entry]) => {
        setEntry(entry);
      }, options);

      // Start observing element.
      observer.observe(ref);

      // Cleanup function;
      return () => {
        observer.disconnect();
      };
    },
    // Avoid excessive re-renders by converting threshold to a string if it is
    // an array.
    [root, rootMargin, JSON.stringify(threshold), ref]
  );

  return [
    (element) => {
      setRef(element);
      setEntry(null);
    },
    entry,
  ];
}

export default useIntersectionObserver;
```

Clients can then use this hook like the following example:

```js showLineNumbers title="useIntersectionObserver.js"
import React from "react";
import useIntersectionObserver from "src/hooks/useIntersectionObserver";

function Component() {
  const [ref, entry] = useIntersectionObserver({
    threshold: 0.5,
  });
  const shouldTransform =
    !entry || (!entry.isIntersecting && entry.boundingClientRect.top > 0);

  return (
    <div
      ref={ref}
      className={`animatable ${
        shouldTransform ? "animatable--initial" : ""
      }`.trim()}
    />
  );
}
```

The css for this example would then look like:

```css showLineNumbers title="block.css"
.block {
  /** Limit transitions to compositor thread friendly properties for the best performance. */
  transition-property: opacity, transform;
  transition-duration: 500ms;
  transition-timing-function: ease-out;
}

.block--initial {
  opacity: 0.5;
  transform: translateX(33%);
}
```

### Step 4: Animate responsibly

When adding any feature to a website, it's important to consider its
accessibility implications. Not everyone likes animations and many people have
vestibular motion disorders where animations can actually cause harm. Therefore,
we should allow users to opt-out of animations.

One relatively easy way we can achieve this is to use the
`prefers-reduced-motion` media query to disable the animation. This will only
set the starting state of the animation if users have not configured their OS to
reduce animations. If they prefer reduced motion, the ending point of the
animation will be rendered which effectively prevents the animation from
running.

```css showLineNumbers title="block.css" {8-12}
.block {
  /** Limit transitions to compositor thread friendly properties for the best performance. */
  transition-property: opacity, transform;
  transition-duration: 500ms;
  transition-timing-function: ease-out;
}

@media (prefers-reduced-motion: no-preference) and (min-width: ) {
  .block--initial {
    opacity: 0.5;
    transform: translateX(33%);
  }
}
```

<iframe
  src="https://codesandbox.io/embed/github/nicholasray/nray.dev/tree/main/content/blog/how-to-create-performant-scroll-animations-in-react/demos/react-scroll-animations?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: "100%",
    height: "500px",
    border: "0",
    "border-radius": "4px",
    overflow: "hidden",
  }}
  title="react-scroll-animations"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>
