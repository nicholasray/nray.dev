---
title: "Interaction to Next Paint (INP): 3 Optimizations You Need to Know"
cover:
  src: ./_assets/interaction-to-next-paint-stroke.jpg
  alt: "Blue paint stroke on white canvas"
  credit:
    "Photo by [Dan Cristian Pădureț](https://unsplash.com/photos/hguxpsaUpBk)"
description:
  "Everything you need to know about the Interaction to Next Paint (INP) Core
  Web Vital"
---

import Image from "@components/BlogImage.astro";

**Interaction to Next Paint (INP)** will become the next **Core Web Vital** on
**March 2024**, replacing **First Input Delay (FID)** as the metric that
measures how quickly a page responds to user interactions.

Is your website fast enough?

At the time of this writing, things aren't looking good for about **35% of
mobile websites**, which are projected to **fail** Google's new web performance
metric.

import BigNumber from "@components/BigNumber.astro";

<BigNumber number={`35.1%`}>
  <>
    The percentage of mobile website origins with failing INP scores (> 200ms)
    as of May 2023. Source: [HTTP
    Archive](https://httparchive.org/reports/chrome-ux-report#cruxFastInp)
  </>
</BigNumber>

**90% of a user's time** on a webpage happens after it loads. Users expect that
when they interact with a page by clicking a button, tapping a menu item, or
pressing a key, visual feedback happens — **and occurs quickly**. INP captures
this interaction latency and flags interactions that are slow enough to cause a
**negative user experience**.
[Rage clicking](https://docs.google.com/presentation/d/1Euu4FBL75z0I8UtKf3dTzrLYu6wxfeWnrmXUCn9AQIY/edit?usp=sharing&resourcekey=0-t6sEnmSbzYTO_fcrR8n9Jg)
is one side effect of interactions that take too long.

This article describes INP and how you can optimize it for your website to
ensure your users have snappy interactions.

## What is Interaction to Next Paint (INP)?

INP is a metric that evaluates how quickly a page visually responds to certain
user interactions.

import inpTimeline from "./_assets/interaction-to-next-paint-timeline.png";

<Image background src={inpTimeline} alt="Interaction to Next Paint Timeline" />

As a Core Web Vital, Google will use INP as one of the signals that influence
your website's search ranking. The upcoming change is expected to provide a more
accurate assessment of a user's experience on a page compared to FID. And the
numbers back this up — as of May 2023,
[99.9% of desktop sites and 93.2% of mobile sites passed FID](https://httparchive.org/reports/chrome-ux-report#cruxFastFid)
with flying colors, but this was mostly because it only measured a _portion_ of
the user's _first interaction_ on a page.

## How is INP Measured?

Throughout the lifespan of a user's visit to a page, each click, tap, and key
press is timed from its beginning to the moment a **visual update** occurs. This
elapsed time represents the **interaction's latency**. When the user leaves the
page, the INP score is calculated based on one of the recorded interaction
latencies.

Notably, the visual update doesn't _need_ to be the final desired visual state.
INP is only concerned with the time it takes to present the **next frame**
following an interaction. The frame _can_ be an **intermediate state** like a
spinner. As long as the interaction results in timely visual feedback that shows
the user _something_ has happened, you can get good INP scores. Just make sure
you use the
[best progress indicator for the situation](https://www.nngroup.com/articles/progress-indicators/).

import inpSpinner from "./_assets/inp-progress-indicator.png";

<Image
  background
  src={inpSpinner}
  alt="Spinner showing after a user interaction"
/>

Intuitively, the page's longest interaction latency is often used as the INP.
The exception is when a user performs over 50 interactions. In this case, the
highest interaction for every 50 interactions is ignored, hopefully reducing
extreme outliers. This might happen with single-page applications (SPAs), for
example.

As with other Core Web Vitals, the **75th percentile** of all the page views is
then reported, further reducing noise.

## What's a good INP score?

At the **75th percentile** for any given page and segmented across desktop and
mobile devices:

- INP \<= **200 milliseconds** indicates a page has **good responsiveness**
- INP \<= **500 milliseconds** indicates a page **needs improvement**
- INP \> **500 milliseconds** indicates a page has **poor responsiveness**

import inpScores from "./_assets/interaction-to-next-paint-scores.png";

<Image background src={inpScores} alt="Interaction to Next Paint Scores" />

## What interactions does INP measure?

INP measures the following interactions:

- Mouse clicks
- Taps on touchscreens
- Key presses (physical and onscreen)

It does NOT measure:

- Hovering
- Scrolling

## What can happen during an interaction?

INP contains **three phases**:

1. **Input delay**: Begins when a user clicks, taps, or presses a key and ends
   when the JavaScript event callbacks start executing
2. **Processing time**: The total execution time of the event callbacks
3. **Presentation delay**: Begins when the event callbacks complete and ends
   when a visual update occurs

import inpComponents from "./_assets/interaction-to-next-paint-components.png";

<Image
  background
  src={inpComponents}
  alt="Interaction to Next Paint Components"
/>

Each of these phases can add time to the interaction's latency. Part of the
reason why First Input Delay rarely failed was because it only measured the
**input delay** portion of the user's first interaction. Because INP measures
all the way to the first frame a user can see, it is much better indicator of a
user's experience.

## How to measure INP

Since INP requires interactions with the page, the best way to measure it is
with real users through Real User Monitoring (RUM). Usually, this involes adding
a small piece of JavaScript to your website that tracks the responsiveness of
each interaction on a page (PageSpeed Insights is a notable exception).

You can use one of the following tools:

- [PageSpeed Insights](https://pagespeed.web.dev/)
- [`web-vitals` JavaScript Library](https://github.com/GoogleChrome/web-vitals)
- [Commerical RUM tools](https://www.google.com/search?q=core+web+vitals+real+user+tools)

### PageSpeed Insights (PSI)

To get a rough idea of the interaction latency your users are experiencing, you
may be able to use data from the
[Chrome UX Report (CrUX)](https://developer.chrome.com/docs/crux/). This is a
convenient option because it doesn't require adding any tracking script to your
website. Instead, Chrome collects this data from
[eligible users](https://developer.chrome.com/docs/crux/methodology/#user-eligibility)
and
[eligible pages](https://developer.chrome.com/docs/crux/methodology/#eligibility)
automatically.

Google's [PageSpeed Insights (PSI)](https://pagespeed.web.dev/) tool is one tool
that makes this data easily accessible. Simply enter a URL and click the
**Analyze** button. Then, look at the "Discover what your real users are
experiencing" section.

import inpPsi from "./_assets/inp-page-speed-insights.png";

<Image background src={inpPsi} alt="Interaction to Next Paint PSI" />

When using this PageSpeeds Insights, you should be aware of the following:

- The displayed data is aggregated for the
  [most recent 28 days of data](https://web.dev/chrome-ux-report/#pagespeed-insights)
- There may not be
  [sufficient data](https://developers.google.com/speed/docs/insights/v5/about#crux)
  for the page or website you're testing. If there isn't sufficient data for the
  page you've entered, PSI will try to use data from all pages of the website —
  the origin — instead. If the origin doesn't have enough data, no data will be
  shown.

### `web-vitals` JavaScript Library

Google released an open source JavaScript library that lets you measure core web
vitals (including INP) from real users. To use it, you'll need to install it
from npm:

```bash
npm install web-vitals
```

Then, import the `attribution` build into your project so that you can get more
details about the interaction:

```js
import { onINP } from "web-vitals/attribution";

function sendToAnalytics(metric) {
  // Instead of logging the output as done below, send desired data to an analytics
  // provider.
  console.log(metric);
}

onINP(sendToAnalytics);
```

The above example produces the following output:

import inpWebVitalsResponse from "./_assets/inp-web-vitals-js-example-response.png";

<Image src={inpWebVitalsResponse} alt="Web Vitals Response Example " />

Importing the `web-vitals/attribution` adds an `attribution.eventEntry` object
which you can use to derive the `input delay`, `processing time` and
`presentation delay`:

- `startTime`: Time in milliseconds at which the interaction occurred.
- `processingStart`: Time at which event callbacks started executing. The input
  delay can be derived from `processingStart - startTime`.
- `processingEnd`: Time at which event callbacks finished executing. The
  `processing time` duration can be derived from
  `processingEnd - processingStart`.
- `duration`: Total duration of interaction rounded to nearest 8 ms. The
  `presentation delay` can be derived from
  `startTime + duration - processingEnd`.

You'll want to send this and other information contained in the object to your
analytics provider.

## What causes poor responsiveness?

Slow interactions are primarily caused by **long tasks** — tasks that last
longer than 50 ms — on the browser's
[main thread](https://developer.mozilla.org/en-US/docs/Glossary/Main_thread).
These tasks refer to discrete units of work carried out by the browser,
including:

- HTML parsing
- Rendering (e.g. style and layout calculations)
- Painting
- JavaScript parsing, compilation, execution
- Garbage collection

Note that the duration of long tasks is often dependent on the user's device.
Low-powered devices like mobile phones with relatively slow CPUs tend to be most
prone to responsiveness issues because the tasks take longer to execute.

In general, if the browser's main thread doesn't have long tasks, it will be
more responsive to user input, and you will get a good INP score.

## How to Optimize Interaction to Next Paint

Since INP involves [three phases](#what-can-happen-during-an-interaction), each
interaction has three opportunities to be slow. Let's examine some of the most
common reasons why **input delay**, **processing time**, and **presentation
delay** can become sluggish and what you can do about it.

## Optimize Input delay

import inpInputDelay from "./_assets/inp-input-delay.png";

<Image src={inpInputDelay} alt="Input delay" />

The first part of each interaction always involves a small, often unnoticeable,
delay that involves converting the interaction into an event that the browser
understands. Once the browser determines the events associated with an
interaction, it can run any event callbacks registered with the events — unless
there is a task blocking that from happening.

import inpBlockedTask from "./_assets/inp-input-delay-blocked-task.png";

<Image background src={inpBlockedTask} alt="Blocked task" />

### Long tasks during startup

The main thread is often the most **congested** when a page loads and
initializes. Script evaluation, rendering work, and painting commonly occur
here.

import inpLongTasksStartup from "./_assets/inp-long-tasks-startup.png";

<Image src={inpLongTasksStartup} alt="Long tasks during startup" />

While there can be a variety of causes for these long tasks, some common
culprits include:

- A single `<script>` tag (without `type=module`) that loads a huge amount of
  JavaScript. Since each `<script>` kicks off a task that evaluates the
  JavaScript when it has been loaded, this can become problematic if the
  evaluation takes a long time. Instead, try to reduce the amount of JavaScript
  you are loading. Also, consider having multiple script tags so that each one
  kicks off its own _smaller_ task that can cause less of an input delay.
- JavaScript that creates or mutates large DOM trees. Pages with a lot of
  elements can lead to very costly rendering tasks. Try to reduce the size of
  your DOM or lazily render elements that are offscreen with
  [`content-visibility`](https://web.dev/content-visibility/)
- [Animations that run on the main thread](https://www.nray.dev/blog/using-chrome-profiler-to-fix-performance-issues/#animations-that-run-on-the-main-thread).
  Instead, animate only `transform` and `opacity` properties so the animation
  can run on the compositor thread.

## Optimize Processing time

import inpProcessingTime from "./_assets/inp-processing-time.png";

<Image src={inpProcessingTime} alt="Processing time" />

### Use debouncing or throttling

E.g. typing into input box

### Eliminate Layout Thrashing

### Show progress

## Optimize presentation delay

import inpPresentationDelay from "./_assets/inp-presentation-delay.png";

<Image src={inpPresentationDelay} alt="Presentation delay" />

## Conclusion

Case studies:

- [RedBus](https://web.dev/redbus-inp/)
- Economic Times
