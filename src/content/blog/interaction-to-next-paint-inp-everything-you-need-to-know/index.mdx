---
title: "Interaction to Next Paint (INP): Everything You Need to Know"
cover:
  src: ./_assets/interaction-to-next-paint-stroke.jpg
  alt: "Blue paint stroke on white canvas"
  credit:
    "Photo by [Dan Cristian Pădureț](https://unsplash.com/photos/hguxpsaUpBk)"
description:
  "Everything you need to know about the Interaction to Next Paint (INP) Core
  Web Vital"
---

import Image from "@components/BlogImage.astro";

**Interaction to Next Paint (INP)** will become the next **Core Web Vital** on
**March 2024**, replacing **First Input Delay (FID)** as the metric that
measures how quickly a page responds to user interactions.

At the time of this writing, things aren't looking good for about **35% of
mobile websites**, which are projected to **fail** Google's new web performance
metric.

import BigNumber from "@components/BigNumber.astro";

<BigNumber number={`35.1%`}>
  <>
    The percentage of mobile website origins with failing INP scores (> 200ms)
    as of May 2023. Source: [HTTP
    Archive](https://httparchive.org/reports/chrome-ux-report#cruxFastInp)
  </>
</BigNumber>

**90% of a user's time** on a webpage happens after it loads. Users expect that
when they interact with a page by clicking a button, tapping a menu item, or
pressing a key, visual feedback happens — **and occurs quickly**. INP captures
this interaction latency and flags interactions that are slow enough to cause a
**negative user experience**.

Although a relatively new metric, **improving INP** has demonstrated to be
important for **user happiness** and **business success**:

- [Rage clicking is one side effect of poor INP](https://docs.google.com/presentation/d/1Euu4FBL75z0I8UtKf3dTzrLYu6wxfeWnrmXUCn9AQIY/edit?usp=sharing&resourcekey=0-t6sEnmSbzYTO_fcrR8n9Jg)
- [redBus increased sales by 7% after improving their INP](https://web.dev/redbus-inp/)
- [Economic times decreased bounce rate by 50% and increased pageviews by 43% by reducing INP nearly 4x](https://web.dev/economic-times-inp/)

This article describes INP and how you can optimize it for your website to
ensure your users have snappy interactions.

## What is Interaction to Next Paint (INP)?

INP is a metric that evaluates how quickly a page visually responds to certain
user interactions.

import inpTimeline from "./_assets/interaction-to-next-paint-timeline.png";

<Image background src={inpTimeline} alt="Interaction to Next Paint Timeline" />

For example:

- When you click a menu button, INP measures how long it takes for the menu to
  appear.
- When you type something into an input field, INP measures how long it takes
  for that character to appear in the field
- When you tap the close button of a slideshow, INP measures how long it takes
  for the slideshow to visually exit

As a Core Web Vital, INP is intended to measure one important aspect of a user's
experience — interactivity and responsiveness. Google will use INP as one of the
signals that influence your website's search ranking.

## What is the difference between First Input Delay (FID) and INP?

The INP metric is First Input Delay's successor and will replace FID as a Core
Web Vital on March 2024. Although both metrics are intended to measure a page's
interactivity and responsiveness, INP is expected to provide a more complete
assessment of a user's experience on a page compared to FID by:

- Observing _all_ interactions throughout the lifetime of a page instead of only
  the first interaction
- Measuring the time it takes from the start of the interaction to moment the
  first frame appears instead of only measuring the time it takes for the
  browser to be able to respond to the interaction (input delay portion)

import inpFid from "./_assets/inp-vs-fid.png";

<Image background src={inpFid} alt="INP vs FID" />

Websites have much worse INP scores compared to FID particularly on mobile
devices — as of May 2023,
[99.9% of desktop sites and 93.2% of mobile sites passed FID](https://httparchive.org/reports/chrome-ux-report#cruxFastFid),
compared to
[96.6% of desktop sites and just **64.9%** of mobile sites passing INP](https://httparchive.org/reports/chrome-ux-report#cruxFastInp).

## How is INP Measured?

Throughout the lifespan of a user's visit to a page, each click, tap, and key
press is timed from its beginning to the moment a **visual update** occurs. This
elapsed time represents the **interaction's latency**. When the user leaves the
page, the INP score is calculated based on one of the recorded interaction
latencies.

import inpSpinner from "./_assets/inp-progress-indicator.png";

<Image
  background
  src={inpSpinner}
  alt="Spinner showing after a user interaction"
/>

Intuitively, the page's longest interaction latency is often used as the INP.
The exception is when a user performs over 50 interactions. In this case, the
highest interaction for every 50 interactions is ignored, hopefully reducing
extreme outliers. This might happen with single-page applications (SPAs), for
example.

As with other Core Web Vitals, the **75th percentile** of all the page views is
then reported, further reducing noise.

Notably, the visual update doesn't _need_ to be the final desired visual state.
INP is only concerned with the time it takes to present the **next frame**
following an interaction. The frame _can_ be an **intermediate state** like a
spinner. As long as the interaction results in timely visual feedback that shows
the user _something_ has happened, you can get good INP scores. For the best
user experience, make sure you use the
[appropriate progress indicator for the situation](https://www.nngroup.com/articles/progress-indicators/).

## What's a good INP score?

At the **75th percentile** for any given page and segmented across desktop and
mobile devices:

- INP \<= **200 milliseconds** indicates a page has **good responsiveness**
- INP \<= **500 milliseconds** indicates a page **needs improvement**
- INP \> **500 milliseconds** indicates a page has **poor responsiveness**

import inpScores from "./_assets/interaction-to-next-paint-scores.png";

<Image background src={inpScores} alt="Interaction to Next Paint Scores" />

## What interactions does INP measure?

INP measures the following interactions:

- **Mouse clicks**
- **Taps on touchscreens**
- **Key presses** (physical and onscreen)

It does NOT measure:

- Hovering
- Scrolling

## What can happen during an interaction?

INP contains **three critical phases**:

1. **Input delay**: Begins when a user clicks, taps, or presses a key and ends
   when the JavaScript event callbacks start executing
2. **Processing time**: The total execution time of the event callbacks
3. **Presentation delay**: Begins when the event callbacks complete and ends
   when a visual update occurs

import inpComponents from "./_assets/interaction-to-next-paint-components.png";

<Image
  background
  src={inpComponents}
  alt="Interaction to Next Paint Components"
/>

Each of these phases can add time to the interaction's latency. Part of the
reason why First Input Delay rarely failed was because it only measured the
**input delay** portion of the user's first interaction. Because INP measures
_all_ the way to the first frame after an interaction, it's a much better
indicator of a user's experience.

## How to measure INP

Since INP requires interactions with the page, the best way to measure it is
with real users through **Real User Monitoring (RUM)**. Usually, this involes
adding a small piece of JavaScript to your website that tracks the
responsiveness of each interaction on a page (PageSpeed Insights is a notable
exception).

You can use one of the following tools:

- [PageSpeed Insights](https://pagespeed.web.dev/)
- [`web-vitals` JavaScript Library](https://github.com/GoogleChrome/web-vitals)
- [Commerical RUM tools](https://www.google.com/search?q=core+web+vitals+real+user+tools)

### PageSpeed Insights (PSI)

If your site has enough traffic, you may be able to use data from Google's
[Chrome UX Report (CrUX)](https://developer.chrome.com/docs/crux/) to get a
rough idea of the interaction latency your users are experiencing. This is a
convenient option because it doesn't require adding any tracking script to your
website. Instead, Chrome collects this data from
[eligible users](https://developer.chrome.com/docs/crux/methodology/#user-eligibility)
and
[eligible pages](https://developer.chrome.com/docs/crux/methodology/#eligibility)
automatically.

Google's [PageSpeed Insights (PSI)](https://pagespeed.web.dev/) tool is one tool
that makes this data easily accessible. Simply enter a URL and click the
**Analyze** button. Then, look at the "Discover what your real users are
experiencing" section.

import inpPsi from "./_assets/inp-page-speed-insights.png";

<Image background src={inpPsi} alt="Interaction to Next Paint PSI" />

When using this PageSpeeds Insights, you should be aware of the following:

- The displayed data is aggregated for the
  [most recent 28 days of data](https://web.dev/chrome-ux-report/#pagespeed-insights)
- There may not be
  [sufficient data](https://developers.google.com/speed/docs/insights/v5/about#crux)
  for the page or website you're testing. If there isn't sufficient data for the
  page you've entered, PSI will try to use data from all pages of the website —
  the origin — instead. If the origin doesn't have enough data, no data will be
  shown.

### `web-vitals` JavaScript Library

Google released an open source JavaScript library that lets you measure core web
vitals (including INP) from real users. To use it, you'll need to install it
from npm:

```bash
npm install web-vitals
```

Then, import the `attribution` build into your project so that you can get more
details about the interaction:

```js
import { onINP } from "web-vitals/attribution";

function sendToAnalytics(metric) {
  // Instead of logging the output as done below, send desired data to an analytics
  // provider.
  console.log(metric);
}

onINP(sendToAnalytics);
```

The above example produces the following output:

import inpWebVitalsResponse from "./_assets/inp-web-vitals-js-example-response.png";

<Image src={inpWebVitalsResponse} alt="Web Vitals Response Example " />

Importing the `web-vitals/attribution` adds an `attribution.eventEntry` object
which you can use to derive the `input delay`, `processing time` and
`presentation delay`:

- `startTime`: Time in milliseconds at which the interaction occurred.
- `processingStart`: Time at which event callbacks started executing. The input
  delay can be derived from `processingStart - startTime`.
- `processingEnd`: Time at which event callbacks finished executing. The
  `processing time` duration can be derived from
  `processingEnd - processingStart`.
- `duration`: Total duration of interaction rounded to nearest 8 ms. The
  `presentation delay` can be derived from
  `startTime + duration - processingEnd`.

You'll want to
[send this](https://github.com/GoogleChrome/web-vitals#send-the-results-to-an-analytics-endpoint)
and other information contained in the object to your analytics provider.

## What causes poor responsiveness?

Slow interactions are primarily caused by **long tasks** — tasks that last
longer than **50 ms** — on the browser's
[**main thread**](https://developer.mozilla.org/en-US/docs/Glossary/Main_thread).
These tasks refer to discrete units of work carried out by the browser,
including:

- **HTML parsing**
- **Rendering** (e.g. style and layout calculations)
- **Painting**
- **JavaScript** parsing, compilation, execution
- **Garbage collection**

Any of these can be responsible for a long task.

The browser's main thread can only execute one task at a time, and that task
must
[run to completion](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop#run-to-completion)
before another task can start. Devices that have lower power, such as mobile
phones with slower CPUs, are more likely to have responsiveness issues because
tasks take longer to complete. That's why it's a good idea to test interactions
on devices that resemble the lower-end devices used by most of your users.

import inpLongTaskSeries from "./_assets/inp-series-of-long-tasks.png";

<Image
  caption="Chrome's performance profiler showing a series of long tasks"
  src={inpLongTaskSeries}
  alt="Series of long tasks"
/>

**In general, if the browser's main thread doesn't have long tasks, it will be
responsive to user input, and interactions will be fast**.

## How to Optimize Interaction to Next Paint

Since INP involves [three phases](#what-can-happen-during-an-interaction), each
interaction has three opportunities to be slow. Let's examine some of the most
common reasons why **input delay**, **processing time**, and **presentation
delay** can become sluggish and what you can do about it.

## Optimize Input delay

import inpInputDelay from "./_assets/inp-input-delay.png";

<Image src={inpInputDelay} alt="Input delay" />

The first part of each interaction always involves a small, often unnoticeable,
delay that involves converting the interaction into an event that the browser
understands. Once the browser determines the events associated with an
interaction, it can run any registered event callbacks — unless there is a task
blocking that from happening.

import inpBlockedTask from "./_assets/inp-input-delay-blocked-task.png";

<Image background src={inpBlockedTask} alt="Blocked task" />

### Long tasks during page startup

The main thread is often the **most congested** when a page loads and
initializes. During this time, the browser is busy parsing HTML, evaluating
scripts, rendering, and painting.

import inpLongTasksStartup from "./_assets/inp-long-tasks-startup.png";

<Image src={inpLongTasksStartup} alt="Long tasks during startup" />

While there can be a variety of causes for these long tasks, some common
culprits include:

- A single `<script>` tag (without the `type=module` attribute) that loads a
  huge amount of JavaScript. Since each `<script>` kicks off a task that
  evaluates the JavaScript when it has been loaded, this can become problematic
  if the evaluation takes a long time. Instead, first try to reduce the amount
  of JavaScript you are loading. Next, consider having multiple script tags so
  that each one kicks off its own _smaller_ task or executing expensive logic in
  a
  [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).
- JavaScript that creates or mutates large DOM trees. Pages with a lot of
  elements can lead to very costly rendering tasks. Instead of using JavaScript
  to mutate the DOM during startup, try to make your server generate the desired
  HTML.

### Rapid interactions

Interactions that occur rapidly, like typing into an autocomplete field, can
cause a high input delay for subsequent interactions.

import inpRapidInteractions from "./_assets/inp-input-delay-rapid-interactions.png";

<Image
  background
  src={inpRapidInteractions}
  alt="Rapid interactions"
  caption='Interactions that happen in close proximity like typing "A" into an input box quickly followed by "B" can cause interaction overlap and a high input delay'
/>

First, try to reduce the callback's JavaScript logic as much as possible. Then,
to avoid a "death by a thousand cuts" problem that can arise from the
accumulation of multiple small callbacks:

- Debounce input handlers
- Cancel any pending `xhr` or `fetch` requests
- If the interaction involves an animation, only animate `transform` and/or
  `opacity` CSS properties so the
  [animation doesn't run on the main thread](https://www.nray.dev/blog/using-chrome-profiler-to-fix-performance-issues/#animations-that-run-on-the-main-thread).

```js
/**
 * An example showing how to debounce input events and cancel pending fetch
 * requests to avoid a high input delay from rapid input events.
 */
const input = document.querySelector("input");
let controller;
let signal;
let timeoutId;

const handler = async (e) => {
  // Cancel any pending requests.
  if (controller) {
    controller.abort();
  }

  controller = new AbortController();
  signal = controller.signal;

  try {
    const response = await fetch(`?q=${e.target.value}`, {
      signal,
    });
    // ...remaining callback logic
  } catch (err) {
    if (err.name === "AbortError") {
      // Ignore "errors" from cancelled requests.
      return;
    }

    throw err;
  }
};

input.addEventListener("input", (e) => {
  // Cancel any pending callbacks.
  clearTimeout(timeoutId);

  // Wait 50 ms before executing callbacks.
  timeoutId = setTimeout(() => handler(e), 50);
});
```

## Optimize processing time

The positive effects of an optimized input delay will be mitigated if the event
callbacks associated with an interaction take forever to execute. But optimizing
your JavaScript execution can help.

import inpProcessingTime from "./_assets/inp-processing-time.png";

<Image src={inpProcessingTime} alt="Processing time" />

### Long tasks from JavaScript execution

One of the most common reasons for a high processing time is from JavaScript
that **takes too long to execute**. This results in a long task on the main
thread that delays important rendering updates.

import inpLongTask from "./_assets/inp-long-task-processing-time.png";

<Image
  caption="In Chrome's performance profiler, long tasks are designated by red diagonal stripes"
  src={inpLongTask}
  alt="Long task"
/>

What can be done about this?

First, investigate the JavaScript responsible for the long task and see if there
is any low-hanging fruit. Sometimes, this will reveal
[**unnecessary JS that can be removed**](/blog/300ms-faster-reducing-wikipedias-total-blocking-time#step-1-remove-unnecessary-javascript)
or
[**inefficient JS that can be optimized**](/blog/300ms-faster-reducing-wikipedias-total-blocking-time#step-2-optimize-existing-javascript).
You may also be able to move some JavaScript off the main thread with
[Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API),
which will free up the main thread to handle interactions.

If you can't reduce the amount of work that JavaScript does on the main thread,
the next best option is to **yield to the main thread** by **spliting up the
work** into **smaller tasks** that each take less than **50 ms** to execute and
prioritizing the work that is user-facing. The benefits of doing this are
two-fold:

1. It allows the browser to render critical work as quickly as possible in the
   next frame, providing the user with fast visual feedback. Remember, the INP
   measurement even allows for intermediate visual feedback states like a
   spinner.
2. Deferring non-essential work to another task in a `setTimeout` callback gives
   the main thread the opportunity to handle higher priority tasks like
   subsequent user input _before_ the `setTimeout`callback is executed.
   Alternatively, you could use
   [`requestIdleCallback`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback),
   but note that it has much less
   [browser support](https://caniuse.com/requestidlecallback).

```js
accordion.addEventListener("click", (event) => {
  // Critical user-visible work that needs to happen before next frame.
  toggleSection(event);

  // Defer less important work to the next frame in another task.
  requesetAnimationFrame(() => {
    setTimeout(() => {
      updateAnalytics(event);
    });
  });
});
```

### Layout Thrashing

**The order of your JavaScript calls can dramatically influence how long it
takes to execute**.

When you read
[properties that trigger layout](https://gist.github.com/paulirish/5d52fb081b3570c81e3a),
such as `element.getBoundingClientRect()`, after making style changes, like
adding a class to an element, the browser will need to perform a
[forced synchronous layout](https://www.nray.dev/blog/using-chrome-profiler-to-fix-performance-issues/#forced-synchronous-layouts)
to calculate the new layout metrics.

```js
// Write
section.classList.add("expanded");
// Read (causing a forced synchronous layout)
section.scrollHeight;
```

This is particularly expensive when multiple forced synchronous layouts in quick
succession are involved. When this happens, it's called
“[layout thrashing](/blog/using-chrome-profiler-to-fix-performance-issues/#layout-thrashing)"
and can significantly increase processing time. This often happens when a read
and write are inside a loop, for example:

```js
const sections = documet.querySelectorAll("section");

// Each iteration causes a forced synchronous layout that results in layout
// thrashing.
sections.forEach((element) => {
  // Write
  section.classList.add("expanded");
  // Read (causing a forced synchronous layout)
  section.scrollHeight;
});
```

To eliminate forced synchronous layouts and layout thrashing, **perform all
reads before any writes**:

```js
const sections = documet.querySelectorAll("section");

// Perform all reads first.
sections.forEach((element) => {
  // Read
  section.scrollHeight;
});

// Then perform all writes.
sections.forEach((element) => {
  // Write
  section.classList.add("expanded");
});
```

## Optimize presentation delay

The last phase that can go wrong is the presentation delay portion which is the
phase that starts after the completion of the event callbacks to the moment the
frame is presented to the user. It also happens to be one of the hardest phases
to optimize.

import inpPresentationDelay from "./_assets/inp-presentation-delay.png";

<Image src={inpPresentationDelay} alt="Presentation delay" />

### Large DOM size

Large presentation delays are often the result of large DOM trees — pages with
more than 1,500 elements. The rendering work that the browser must do in order
to produce a frame correlates with the size of the DOM. As a result and in
general, **the larger the DOM size, the longer it takes for the browser to
render updates**.

To minimize, the effects of a large DOM size, you can hide certain elements by
default with one of the following methods:

- `display: none` CSS style
- [`hidden=until-found`](https://developer.chrome.com/articles/hidden-until-found/)
  HTML attribute

This pattern can work well for collapsing sections that are part of an accordion
component, for example. While the elements are hidden, they are removed from the
browser's rendering tree which eliminates their rendering costs. Then, you can
programmatically show an element after an interaction — like clicking on an
accordion section — which adds it to the rendering tree. Wikipedia uses this
technique on its mobile site for most sections on the page.

import hiddenUntilFound from "./_assets/wikipedia-mobile-hidden-until-found-attribute.png";

<Image
  src={hiddenUntilFound}
  alt="Hidden until found"
  caption="Wikipedia's mobile site uses the `hidden=until-found` attribute to hide most of an article's sections by default. This helps reduce the page's presentation delay."
/>

A more advanced technique involves using the
[`content-visibility: auto`](https://web.dev/content-visibility/) CSS style to
lazily render off-screen elements.
