<div class="mt-4 flex justify-center">
  <div class="flex max-w-md flex-grow flex-col">
    <div class="flex justify-between">
      <label for="inp-text-input">Additional latency:</label>
      <span class="inp-input-value">0 ms</span>
    </div>
    <input
      class="mt-3 block"
      id="inp-text-input"
      type="range"
      min="0"
      max="500"
      value="0"
      step="50"
    />
  </div>
</div>

<div class="mt-8">
  <input
    class="inp-input text-input w-full p-2 shadow-xl"
    type="text"
    placeholder="Type something..."
  />
</div>

<div class="inp-scale relative mb-12">
  <div class="flex text-center">
    <div class="flex-auto basis-[200px] bg-green-200 py-8">GOOD</div>
    <div class="flex-auto basis-[300px] bg-orange-200 py-8">
      NEEDS IMPROVEMENT
    </div>
    <div class="flex-auto basis-[200px] bg-red-200 py-8">POOR</div>
  </div>
  <div class="flex -translate-y-1/3 justify-center">
    <div
      class="inp-scale__score relative flex min-h-[2rem] min-w-[5rem] items-center justify-center rounded-full bg-white px-2 opacity-0 shadow-lg"
    >
    </div>
  </div>
</div>

<script>
  import { onINP } from "web-vitals";
  import { animate, spring } from "motion";
  const scale = document.querySelector(".inp-scale")! as HTMLElement;
  const latencyRange = document.querySelector("input")!;
  const latencyValue = document.querySelector(".inp-input-value")!;
  const input = document.querySelector(".inp-input")!;
  const score = document.querySelector(".inp-scale__score")! as HTMLElement;
  const RANGE = 700;

  latencyRange.addEventListener("input", () => {
    latencyValue.textContent = `${latencyRange.value} ms`;
  });

  input.addEventListener("keydown", () => {
    const t0 = performance.now();
    const delay = parseInt(latencyRange.value);

    while (performance.now() - t0 < delay);
  });

  const getRelativeBox = (parent: HTMLElement, child: HTMLElement) => {
    const parentBox = parent.getBoundingClientRect();
    const childBox = child.getBoundingClientRect();

    return {
      width: childBox.width,
      height: childBox.height,
      x: childBox.x === 0 ? 0 : childBox.x - parentBox.x,
      y: childBox.y === 0 ? 0 : childBox.y - parentBox.y,
    };
  };

  onINP(
    (interaction) => {
      // First
      const before = getRelativeBox(scale, score);

      // Set change
      scale.classList.add("inp-scale--active");
      score.textContent = interaction.value.toString();
      score.style.left = `${(
        Math.min((interaction.value - RANGE / 2) / RANGE, 0.5) * 100
      ).toFixed(2)}%`;

      // Last
      const after = getRelativeBox(scale, score);

      // Invert
      const invert = before.x - after.x;

      animate(
        score,
        {
          opacity: [1, 1],
          x: [invert, 0],
          // transform: [`translateX(${invert}px)`, "translateX(0)"],
        },
        // { easing: [0.34, 1.56, 0.64, 1], duration: 0.5 }
        { easing: spring({ damping: 30, stiffness: 600 }) }
      );
    },
    {
      durationThreshold: 0,
      reportAllChanges: true,
    }
  );
</script>
