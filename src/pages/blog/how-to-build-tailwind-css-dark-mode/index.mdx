---
title: "How to Build Tailwind CSS Dark Mode"
layout: "@layouts/BlogLayout.astro"
cover:
  filename: sea-at-night.jpg
  alt: "A view of the expansive sea on a cloudy night with a bright moon"
  credit: "Photo by [Kyle Johnson](https://unsplash.com/photos/8Gl7Ew-q6D8)"
draft: true
description:
  Learn step-by-step instructions on how to implement a sleek dark mode theme
  for your website using Tailwind CSS.
---

import BlogIframe from "@components/BlogIframe.astro";
import Image from "@components/BlogImage.astro";
import Video from "@components/BlogVideo.astro";

Have you ever visited a website in a dark room that smothers the screen in
bright white pixels?

Besides being
[easier on the eyes](https://medium.com/dev-channel/let-there-be-darkness-maybe-9facd9c3023d),
a website that offers a dark mode option may:

- [increase reading rates for people with cataract and other visual disorders](https://www.nngroup.com/articles/dark-mode/)
- [reduce power use by 63% on AMOLED screens](https://www.techspot.com/news/77340-dark-mode-saves-lot-phone-battery-life-google.html)
- [promote better sleep by emitting less blue light](https://www.sleepfoundation.org/bedroom-environment/blue-light),
  although [it's debatable](https://www.eurekalert.org/news-releases/642949)
- [look elegant and beautiful](https://medium.com/dev-channel/let-there-be-darkness-maybe-9facd9c3023d)

In this article, you'll learn how to implement a dark mode theme using
[Tailwind CSS](https://tailwindcss.com/), one of the most popular CSS frameworks
at the time of this writing. Nevertheless, many of the concepts presented here
can apply to other dark mode implementations.

## Using the dark mode variant class in Tailwind CSS

Tailwind CSS allows you to easily style elements using a set of utility classes,
and adding dark mode support is no different. Simply prefix any supported class
name with `dark:`, and that class will only become active when the user has
enabled their operating system's dark mode setting.

The following example defaults to a white background with dark gray text if the
user hasn't enabled dark mode on their operating system. If they have, the box
will have a dark gray background with white text:

<BlogIframe
  class="h-40 w-72"
  src="/blog/how-to-build-tailwind-css-dark-mode/demos/dark-variant"
/>

```html /dark:bg-gray-900/
<div
  class="h-full rounded-lg bg-white p-4 text-gray-900 shadow-lg dark:bg-gray-700 dark:text-white"
>
  <span class="dark:hidden">Light mode</span>
  <span class="hidden dark:block">Dark mode</span>
</div>
```

Switching between dark mode and light mode on your operating system changes the
website's theme as well:

import macAppearancePanelWebM from "./assets/mac-os-appearance-panel.webm";
import macAppearancePanelMp4 from "./assets/mac-os-appearance-panel.mp4";

<Video
  description="Video showing that switching to dark mode on MacOS makes the example box have a dark background color. Switching to light mode makes the example box makes the example box have a light background color."
  width="1818"
  height="1080"
  src={[macAppearancePanelWebM, macAppearancePanelMp4]}
/>

How does this happen?

If you inspect the styles of the `<div>` above when dark mode is active, you'll
see that the `dark:` prefix adds a wrapping `prefers-color-scheme` media query
around the `background-color` and `color` properties, so that the styles only
become active when the user has enabled dark mode on their device:

import prefersMediaQuery from "./assets/prefers-color-scheme-media-query.png";

<Image
  class="shadow-xl"
  src={prefersMediaQuery}
  alt="Prefers media query screenshot"
/>

```css
/** default or light mode styles */
.bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}

/*
dark mode styles that will only be applied if the user has enabled dark mode on
their system
*/
@media (prefers-color-scheme: dark) {
  .dark\:bg-gray-700 {
    --tw-bg-opacity: 1;
    background-color: rgb(55 65 81 / var(--tw-bg-opacity));
  }
}
```

By default, the `dark` variant prefix relies on the device's theme setting via
the `prefers-color-scheme` media query. But what if you wanted to add a toggle
button to your website that allowed users to switch between themes independent
of their system's preference?

## Using the 'class' strategy

In order to enable the user to switch themes using a toggle on your website, you
need to toggle a `dark` class on the `html` element. Tailwind calls this the
`class` strategy.

To enable the `class` strategy, modify your `tailwind.config.js` file:

```js title="tailwind.config.js"
module.exports = {
  // Determine whether dark mode is enabled from the `dark` class on the `html`
  // element.
  darkMode: "class",
  // ...
};
```

Next, you need to implement behavior that adds or removes the `dark` class when
the user clicks the toggle button. A naive implementation might look like the
following:

```js
const button = document.querySelector("button");
button.addEventListener("click", () => {
  // Add or remove the 'dark' class from the 'html' element.
  document.documentElement.classList.toggle("dark");
});
```

Easy, right? Well, there are a couple additional considerations when toggling
the theme.

## `theme-color` meta tag

Adding a dark mode toggle to your website won't affect the surrounding color of
the browser's user interface. But there is a `<meta>` tag that can help with
that. The `theme-color` meta tag suggests the color that browsers should use:

```html
<meta name="theme-color" content="#4285f4" />
```

import metaThemeColor from "./assets/meta-theme-color.png";

<Image
  class="shadow-xl"
  src={metaThemeColor}
  alt="Side-by-side comparison of site with meta theme-color tag vs. site without meta theme-color tag. The usage of meta theme-color applies a color to the browser's interface around the webiste."
/>

## `color-scheme` meta tag

The second `meta` tag, named `color-scheme`, controls the default appearance of
browser-provided UI such as
[form controls, scroll bars, spellcheck underlines, and more](https://color-scheme-demo.glitch.me/):

```html
<meta name="color-scheme" content="dark" />
```

import metaColorScheme from "./assets/meta-color-scheme.png";

<Image
  class="shadow-xl"
  src={metaColorScheme}
  alt="Side-by-side comparison of site with meta color-scheme tag vs. site without meta color-scheme tag. The usage of meta color-scheme tag applies a lighter blue color to the checkboxes."
/>

## Theme persistence

For the best user experience, save the user's theme choice so that after they
reloads or visit a new page of your website, their setting remains or
"persists". To do this, you'll need to save their choice in the browser. You can
either use a `cookie` or `localstorage`, but `localstorage` is commonly used.

To avoid a
[flash of unstyled content](https://en.wikipedia.org/wiki/Flash_of_unstyled_content),
add an inline script in the `<head>`. Why? Inline scripts are
[render-blocking](https://developers.google.com/speed/docs/insights/BlockingJS)
and block the browser from parsing HTML. This is usually undesirable from a
performance perspective, but advantageous in this case because we don't _want_
the browser to render anything until we know which theme the website uses:

```html title="index.html"
<!DOCTYPE html>
<html>
  <head>
    <!--Render-blocking inline script-->
    <script>
      // Check if the user has previously toggled the theme.
      var theme = localStorage.getItem("theme");

      if (theme === "dark") {
        // Switch to dark mode.
        document.documentElement.classList.add("dark");
      }
    <script>
    ...
```

It's tempting to think that users who prefer dark mode will flock to any theme
button you add to the page. But most users
[won't bother customizing their experience](https://www.nngroup.com/articles/customization-of-uis-and-products)
â€” they just want to get things done. Therefore, it's essential to have a
sensible default. We can default to the system's color theme if the user hasn't
used the website's toggle button:

```html {8} title="index.html"
    <script>
      // Check if the user has previously toggled the theme.
      var theme = localStorage.getItem("theme");

      if (
        theme === "dark" ||
        // Default to the system's setting.
        (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        // Switch to dark mode.
        document.documentElement.classList.add("dark");
      }
    <script>
    ...
```

We can also add and toggle the `<meta>` tags discussed previously here:

```html {4-15, 25-33} title="index.html"
<!DOCTYPE html>
<html>
  <head>
    <meta
      class="meta-theme"
      name="theme-color"
      content="#FAFAFA"
      data-other="#18181B"
    />
    <meta
      class="meta-theme"
      name="color-scheme"
      content="light"
      data-other="dark"
    />
    <script>
      // Check if the user has previously toggled the theme.
      var theme = localStorage.getItem("theme");

      if (
        theme === "dark" ||
        // Default to the system's setting.
        (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        // Iterate through the relevant meta tags and change their value to
        // values suitable for dark mode.
        var metaTags = document.head.querySelectorAll(".meta-theme");
        for (var i = 0; i < metaTags.length; i++) {
          var meta = metaTags[i];
          var other = meta.dataset.other;
          meta.dataset.other = meta.content;
          meta.content = other;
        }

        // Switch to dark mode.
        document.documentElement.classList.add("dark");
      }
    </script>
  </head>
  ...
</html>
```

## Building the toggle

Now let's focus on building the actual toggle. We'll start a minimal toggle
button:

```html title="index.html"
<button
  class="theme-toggle block rounded-full p-3 hover:bg-zinc-100 dark:hover:bg-zinc-800 dark:hover:text-white"
>
  <div class="dark:hidden">Dark</div>
  <div class="hidden dark:block">Light</div>
</button>
```

In the example above, the button's "Dark" label is shown when light mode is
active. The `dark:hidden` class is used to hide the "Dark" label when dark mode
is active and instead show the "Light" label with the `dark:block` class.

Now, we need JavaScript to handle clicks to the toggle button. When the button
is clicked, the `dark` class should be added to the `html` element:

```js title="script.js"
function enableLightMode() {
  document.documentElement.classList.remove("dark");
}

function enableDarkMode() {
  document.documentElement.classList.add("dark");
}

function bindButtonListener() {
  // Bind button click listener.
  const button = document.querySelector("button");
  button.addEventListener("click", () => {
    const isDark = document.documentElement.classList.contains("dark");

    if (isDark) {
      enableLightMode();
    } else {
      enableDarkMode();
    }
  });
}

function init() {
  bindButtonListener();
}

init();
```

The next step is adding persistence so that the theme remains after reloading or
going to a new page:

```js {1-3, 7, 12} title="script.js"
function persistTheme(theme) {
  localStorage.setItem("theme", theme);
}

function enableLightMode() {
  document.documentElement.classList.remove("dark");
  persistTheme("light");
}

function enableDarkMode() {
  document.documentElement.classList.add("dark");
  persistTheme("dark");
}
```

As we did in the `<head>`, we use `localStorage` for persistence. But instead of
retrieving the theme from `localStoarge`, we save it.

We can also toggle the meta tags that we added to the `<head>`:

```js {1-9, 14, 20} title="script.js"
function toggleMeta() {
  const metaTags = document.head.querySelectorAll(".meta-theme");
  for (var i = 0; i < metaTags.length; i++) {
    const meta = metaTags[i];
    const other = meta.dataset.other;
    meta.dataset.other = meta.content;
    meta.content = other;
  }
}

function enableLightMode() {
  document.documentElement.classList.remove("dark");
  persistTheme("light");
  toggleMeta();
}

function enableDarkMode() {
  document.documentElement.classList.add("dark");
  persistTheme("dark");
  toggleMeta();
}
```

Finally, it would be nice if the website's theme color changed when the user
changed their system's theme color. We can do that by using the
[`matchMedia`](/blog/using-media-queries-in-javascript) API

```js {1-21, 25} title="script.js"
function handleSystemChange(e) {
  if (e.matches) {
    // User has enabled their system's dark mode setting.
    enableDarkMode();
  } else {
    // User has enabled their system's light mode setting.
    enableLightMode();
  }
}

function bindMediaQueryListener() {
  // Handle system theme changes.
  const mediaQueryList = window.matchMedia("(prefers-color-scheme: dark)");
  if (mediaQueryList.addEventListener) {
    mediaQueryList.addEventListener("change", handleSystemChange);
  } else {
    // In Safari versions < 14, the `addEventListener` API is not available, so
    // use `addListener` method instead.
    mediaQueryList.addListener(handleSystemChange);
  }
}

function init() {
  bindButtonListener();
  bindMediaQueryListener();
}

init();
```

Check out the
[full demo](https://codesandbox.io/p/sandbox/nray-dev-how-to-build-tailwind-css-dark-mode-rl20n9?file=%2Fscript.js).
